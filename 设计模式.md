## 单例模式 （Singleton）
Singleton模式是设计模式中最为简单、最为常见、最容易实现，也是最应该熟悉和掌握的模式。

Singleton模式就是一个类只创建一个唯一的对象，即一次创建多次使用。

### 实现单例模式的步骤：
1. 构造函数私有化
2. 增加静态私有的当前类的指针变量
3. 提供静态对外接口,可以让用户获得单例对象

**饿汉式**：还没有使用该单例对象，该单例对象就已经被加载到内存了，在对象过多时会造成内存浪费

**懒汉式**：解决了饿汉式内存浪费问题，但是线程不安全的，可以通过互斥量mutex.lock()和mutex.unlock()来解决

**总结**：
Singleton不可以被实例化，因此将其构造函数声明private；

Singleton模式经常和Factory（AbstractFactory）模式在一起使用，因为系统中工厂对象一般来说只要一个。

**代码:**
```C++
#include <iostream>
using namespace std;

class A
{
    public:
        static A *getInstace()
        {
            return a;
        }

    private:
        A()
        {
            a = new A;
        }
        static A *a;
};

A *A::a = NULL;

//懒汉式:对象的创建在第一次调用getInstance函数时创建
//懒汉式是线程不安全的
class SingletonLazy
{
    public:
        static SingletonLazy *getInstance()
        {
            if (pSingleton == NULL)
            {
                pSingleton = new SingletonLazy;
            }
            return pSingleton;
        }

    private:
        SingletonLazy() {}
        static SingletonLazy *pSingleton;
};

//在类外面进行初始化
SingletonLazy *SingletonLazy::pSingleton = NULL;

//饿汉式:对象在程序执行时优先创建
//饿汉式是线程安全的
class SingletonHungry
{
    public:
        static SingletonHungry *getInstance()
        {
            return pSingleton;
        }

        static void freeSpace()
        {
            if (pSingleton != NULL)
            {
                delete pSingleton;
            }
        }

    private:
        SingletonHungry() {}
        static SingletonHungry *pSingleton;
};

//以下语句将会在main函数运行前执行
SingletonHungry *SingletonHungry::pSingleton = new SingletonHungry;

int main()
{
    SingletonLazy *p1 = SingletonLazy::getInstance();
    SingletonLazy *p2 = SingletonLazy::getInstance();
    if (p1 == p2)
    {
        cout << "单例模式" << endl;
    }
    else
    {
        cout << "不是单例模式" << endl;
    }

    SingletonHungry *p3 = SingletonHungry::getInstance();
    SingletonHungry *p4 = SingletonHungry::getInstance();
    if (p3 == p4)
    {
        cout << "单例模式" << endl;
    }
    else
    {
        cout << "不是单例模式" << endl;
    }
}

```


## 设计模式六大原则
1. 单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。
2. 开放封闭原则：软件实体可以扩展，但是不可修改。即面对需求，对程序的改动可以通过增加代码来完成，但是不能改动现有的代码。
3. 里氏代换原则：一个软件实体如果使用的是一个基类，那么一定适用于其派生类。即在软件中，把基类替换成派生类，程序的行为没有变化。
4. 依赖倒转原则：抽象不应该依赖细节，细节应该依赖抽象。即针对接口编程，不要对实现编程。
5. 迪米特原则：如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某个方法的话，可以通过第三个类转发这个调用。
6. 接口隔离原则：每个接口中不存在派生类用不到却必须实现的方法，如果不然，就要将接口拆分，使用多个隔离的接口。

## 请说说工厂设计模式，如何实现，以及它的优点
1. 工厂设计模式的定义

定义一个创建对象的接口，让子类决定实例化哪个类，而对象的创建统一交由工厂去生产，有良好的封装性，既做到了解耦，也保证了最少知识原则。

2. 工厂设计模式分类

工厂模式属于创建型模式，大致可以分为三类，**简单工厂模式**、**工厂方法模式**、**抽象工厂模式**。

（1）简单工厂模式

它的主要特点是需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类。

**优点**： 简单工厂模式可以根据需求，动态生成使用者所需类的对象，而使用者不用去知道怎么创建对象，使得各个模块各司其职，降低了系统的耦合性。

**缺点**：就是要增加新的核类型时，就需要修改工厂类。这就违反了开放封闭原则：软件实体（类、模块、函数）可以扩展，但是不可修改。

**示例**：
```C++
//程序实例（简单工厂模式）
enum CTYPE {COREA, COREB};     
class SingleCore    
{    
public:    
    virtual void Show() = 0;  
};    
//单核A    
class SingleCoreA: public SingleCore    
{    
public:    
    void Show() { cout<<"SingleCore A"<<endl; }    
};    
//单核B    
class SingleCoreB: public SingleCore    
{    
public:    
    void Show() { cout<<"SingleCore B"<<endl; }    
};    
//唯一的工厂，可以生产两种型号的处理器核，在内部判断    
class Factory    
{    
public:     
    SingleCore* CreateSingleCore(enum CTYPE ctype)    
    {    
        if(ctype == COREA) //工厂内部判断    
            return new SingleCoreA(); //生产核A    
        else if(ctype == COREB)    
            return new SingleCoreB(); //生产核B    
        else    
            return NULL;    
    }    
};  
```

（2）工厂方法模式

所谓工厂方法模式，是指定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。

**优点**： 扩展性好，符合了开闭原则，新增一种产品时，只需增加改对应的产品类和对应的工厂子类即可。

**缺点**：每增加一种产品，就需要增加一个对象的工厂。如果这家公司发展迅速，推出了很多新的处理器核，那么就要开设相应的新工厂。在C++实现中，就是要定义一个个的工厂类。显然，相比简单工厂模式，工厂方法模式需要更多的类定义。

```C++
//程序实例（工厂方法模式）
class SingleCore    
{    
public:    
    virtual void Show() = 0;  
};    
//单核A    
class SingleCoreA: public SingleCore    
{    
public:    
    void Show() { cout<<"SingleCore A"<<endl; }    
};    
//单核B    
class SingleCoreB: public SingleCore    
{    
public:    
    void Show() { cout<<"SingleCore B"<<endl; }    
};    
class Factory    
{    
public:    
    virtual SingleCore* CreateSingleCore() = 0;  
};    
//生产A核的工厂    
class FactoryA: public Factory    
{    
public:    
    SingleCoreA* CreateSingleCore() { return new SingleCoreA; }    
};    
//生产B核的工厂    
class FactoryB: public Factory    
{    
public:    
    SingleCoreB* CreateSingleCore() { return new SingleCoreB; }    
};  
```

（3）抽象工厂模式

优点： 工厂抽象类创建了多个类型的产品，当有需求时，可以创建相关产品子类和子工厂类来获取。

缺点： 扩展新种类产品时困难。抽象工厂模式需要我们在工厂抽象类中提前确定了可能需要的产品种类，以满足不同型号的多种产品的需求。但是如果我们需要的产品种类并没有在工厂抽象类中提前确定，那我们就需要去修改工厂抽象类了，而一旦修改了工厂抽象类，那么所有的工厂子类也需要修改，这样显然扩展不方便。

```C++
//程序实例（抽象工厂模式）
//单核    
class SingleCore     
{    
public:    
    virtual void Show() = 0;  
};    
class SingleCoreA: public SingleCore      
{    
public:    
    void Show() { cout<<"Single Core A"<<endl; }    
};    
class SingleCoreB :public SingleCore    
{    
public:    
    void Show() { cout<<"Single Core B"<<endl; }    
};    
//多核    
class MultiCore      
{    
public:    
    virtual void Show() = 0;  
};    
class MultiCoreA : public MultiCore      
{    
public:    
    void Show() { cout<<"Multi Core A"<<endl; }    

};    
class MultiCoreB : public MultiCore      
{    
public:    
    void Show() { cout<<"Multi Core B"<<endl; }    
};    
//工厂    
class CoreFactory      
{    
public:    
    virtual SingleCore* CreateSingleCore() = 0;  
    virtual MultiCore* CreateMultiCore() = 0;  
};    
//工厂A，专门用来生产A型号的处理器    
class FactoryA :public CoreFactory    
{    
public:    
    SingleCore* CreateSingleCore() { return new SingleCoreA(); }    
    MultiCore* CreateMultiCore() { return new MultiCoreA(); }    
};    
//工厂B，专门用来生产B型号的处理器    
class FactoryB : public CoreFactory    
{    
public:    
    SingleCore* CreateSingleCore() { return new SingleCoreB(); }    
    MultiCore* CreateMultiCore() { return new MultiCoreB(); }    
};   
```

三种工厂模式的UML图如下：

1. 简单工厂模式UML

![简单工厂](/img/factory1.png)

2. 工厂方法的UML图

![工厂方法](/img/factory2.png)

3. 抽象工厂模式的UML图

![抽象工厂模式](/img/factory3.png)

## 请说说装饰器计模式，以及它的优缺点
1. 装饰器计模式的定义

指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。

2. 优点

（1）装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用；

（2）通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果；

（3）装饰器模式完全遵守开闭原则。

3. 缺点

装饰模式会增加许多子类，过度使用会增加程序得复杂性。

4. 装饰模式的结构与实现

通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。下面来分析其基本结构和实现方法。

装饰模式主要包含以下角色：

（1）抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。

（2）具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。

（3）抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。

（4）具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

![Decorator](/img/Decorator.png)

```C++
#include <string>
#include <iostream>

//基础组件接口定义了可以被装饰器修改的操作
class Component
{
public:
    virtual ~Component() {}
    virtual std::string Operation() const = 0;
};

//具体组件提供了操作的默认实现。这些类在程序中可能会有几个变体
class ConcreteComponent : public Component
{
public:
    std::string Operation() const override
    {
        return "ConcreteComponent";
    }
};

//装饰器基类和其他组件遵循相同的接口。这个类的主要目的是为所有的具体装饰器定义封装接口。
//封装的默认实现代码中可能会包含一个保存被封装组件的成员变量，并且负责对齐进行初始化
class Decorator : public Component
{

protected:
    Component *component_;

public:
    Decorator(Component *component) : component_(component)
    {
    }

    //装饰器会将所有的工作分派给被封装的组件
    std::string Operation() const override
    {
        return this->component_->Operation();
    }
};

//具体装饰器必须在被封装对象上调用方法，不过也可以自行在结果中添加一些内容。
class ConcreteDecoratorA : public Decorator
{

    //装饰器可以调用父类的是实现，来替代直接调用组件方法。
public:
    ConcreteDecoratorA(Component *component) : Decorator(component)
    {
    }
    std::string Operation() const override
    {
        return "ConcreteDecoratorA(" + Decorator::Operation() + ")";
    }
};

//装饰器可以在调用封装的组件对象的方法前后执行自己的方法
class ConcreteDecoratorB : public Decorator
{
public:
    ConcreteDecoratorB(Component *component) : Decorator(component)
    {
    }

    std::string Operation() const override
    {
        return "ConcreteDecoratorB(" + Decorator::Operation() + ")";
    }
};

//客户端代码可以使用组件接口来操作所有的具体对象。这种方式可以使客户端和具体的实现类脱耦
void ClientCode(Component *component)
{
    // ...
    std::cout << "RESULT: " << component->Operation();
    // ...
}

int main()
{

    Component *simple = new ConcreteComponent;
    std::cout << "Client: I've got a simple component:\n";
    ClientCode(simple);
    std::cout << "\n\n";

    Component *decorator1 = new ConcreteDecoratorA(simple);
    Component *decorator2 = new ConcreteDecoratorB(decorator1);
    std::cout << "Client: Now I've got a decorated component:\n";
    ClientCode(decorator2);
    std::cout << "\n";

    delete simple;
    delete decorator1;
    delete decorator2;

    return 0;
}
```

## 请说说观察者设计模式，如何实现
1. 观察者设计模式的定义

指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，**所有依赖于它的对象都得到通知并被自动更新**。这种模式有时又称作**发布-订阅模式**、模型-视图模式，它是**对象行为型模式**。

2. 优点

（1）降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。

（2）目标与观察者之间建立了一套触发机制。

3. 缺点

（1）目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。

（2）当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。

4. 观察者设计模式的结构与实现

观察者模式的主要角色如下：

（1）抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。

（2）具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。

（3）抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。

（4）具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。

5. 举例
举个博客订阅的例子，当博主发表新文章的时候，即博主状态发生了改变，那些订阅的读者就会收到通知，然后进行相应的动作，比如去看文章，或者收藏起来。

博主与读者之间存在种一对多的依赖关系。

下面给出相应的UML图设计:

![observer](/img/observer.png)

```C++
//观察者
class Observer  
{
public:
    Observer() {}
    virtual ~Observer() {}
    virtual void Update() {} 
};
//博客
class Blog  
{
public:
    Blog() {}
    virtual ~Blog() {}
    void Attach(Observer *observer) { m_observers.push_back(observer); }     //添加观察者
    void Remove(Observer *observer) { m_observers.remove(observer); }        //移除观察者
    void Notify() //通知观察者
    {
        list<Observer*>::iterator iter = m_observers.begin();
        for(; iter != m_observers.end(); iter++)
            (*iter)->Update();
    }
    virtual void SetStatus(string s) { m_status = s; } //设置状态
    virtual string GetStatus() { return m_status; }    //获得状态
private:
    list<Observer* > m_observers; //观察者链表
protected:
    string m_status; //状态
};
```

以上是观察者和博客的基类，定义了通用接口。博客类主要完成观察者的添加、移除、通知操作，设置和获得状态仅仅是一个默认实现。下面给出它们相应的子类实现。

```C++
//具体博客类
class BlogCSDN : public Blog
{
private:
    string m_name; //博主名称
public:
    BlogCSDN(string name): m_name(name) {}
    ~BlogCSDN() {}
    void SetStatus(string s) { m_status = "CSDN通知 : " + m_name + s; } //具体设置状态信息
    string GetStatus() { return m_status; }
};
//具体观察者
class ObserverBlog : public Observer   
{
private:
    string m_name;  //观察者名称
    Blog *m_blog;   //观察的博客，当然以链表形式更好，就可以观察多个博客
public: 
    ObserverBlog(string name,Blog *blog): m_name(name), m_blog(blog) {}
    ~ObserverBlog() {}
    void Update()  //获得更新状态
    { 
        string status = m_blog->GetStatus();
        cout<<m_name<<"-------"<<status<<endl;
    }
};
```

```C++
//测试案例
int main()
{
    Blog *blog = new BlogCSDN("wuzhekai1985");
    Observer *observer1 = new ObserverBlog("tutupig", blog);
    blog->Attach(observer1);
    blog->SetStatus("发表设计模式C++实现（15）——观察者模式");
    blog->Notify();
    delete blog; delete observer1;
    return 0;
}
```