## 单例模式 （Singleton）
Singleton模式是设计模式中最为简单、最为常见、最容易实现，也是最应该熟悉和掌握的模式。

Singleton模式就是一个类只创建一个唯一的对象，即一次创建多次使用。

### 实现单例模式的步骤：
1. 构造函数私有化
2. 增加静态私有的当前类的指针变量
3. 提供静态对外接口,可以让用户获得单例对象

**饿汉式**：还没有使用该单例对象，该单例对象就已经被加载到内存了，在对象过多时会造成内存浪费

**懒汉式**：解决了饿汉式内存浪费问题，但是线程不安全的，可以通过互斥量mutex.lock()和mutex.unlock()来解决

**总结**：
Singleton不可以被实例化，因此将其构造函数声明private；

Singleton模式经常和Factory（AbstractFactory）模式在一起使用，因为系统中工厂对象一般来说只要一个。

**代码:**
```C++
#include <iostream>
using namespace std;

class A
{
    public:
        static A *getInstace()
        {
            return a;
        }

    private:
        A()
        {
            a = new A;
        }
        static A *a;
};

A *A::a = NULL;

//懒汉式:对象的创建在第一次调用getInstance函数时创建
//懒汉式是线程不安全的
class SingletonLazy
{
    public:
        static SingletonLazy *getInstance()
        {
            if (pSingleton == NULL)
            {
                pSingleton = new SingletonLazy;
            }
            return pSingleton;
        }

    private:
        SingletonLazy() {}
        static SingletonLazy *pSingleton;
};

//在类外面进行初始化
SingletonLazy *SingletonLazy::pSingleton = NULL;

//饿汉式:对象在程序执行时优先创建
//饿汉式是线程安全的
class SingletonHungry
{
    public:
        static SingletonHungry *getInstance()
        {
            return pSingleton;
        }

        static void freeSpace()
        {
            if (pSingleton != NULL)
            {
                delete pSingleton;
            }
        }

    private:
        SingletonHungry() {}
        static SingletonHungry *pSingleton;
};

//以下语句将会在main函数运行前执行
SingletonHungry *SingletonHungry::pSingleton = new SingletonHungry;

int main()
{
    SingletonLazy *p1 = SingletonLazy::getInstance();
    SingletonLazy *p2 = SingletonLazy::getInstance();
    if (p1 == p2)
    {
        cout << "单例模式" << endl;
    }
    else
    {
        cout << "不是单例模式" << endl;
    }

    SingletonHungry *p3 = SingletonHungry::getInstance();
    SingletonHungry *p4 = SingletonHungry::getInstance();
    if (p3 == p4)
    {
        cout << "单例模式" << endl;
    }
    else
    {
        cout << "不是单例模式" << endl;
    }
}

```


## 设计模式六大原则
1. 单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。
2. 开放封闭原则：软件实体可以扩展，但是不可修改。即面对需求，对程序的改动可以通过增加代码来完成，但是不能改动现有的代码。
3. 里氏代换原则：一个软件实体如果使用的是一个基类，那么一定适用于其派生类。即在软件中，把基类替换成派生类，程序的行为没有变化。
4. 依赖倒转原则：抽象不应该依赖细节，细节应该依赖抽象。即针对接口编程，不要对实现编程。
5. 迪米特原则：如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某个方法的话，可以通过第三个类转发这个调用。
6. 接口隔离原则：每个接口中不存在派生类用不到却必须实现的方法，如果不然，就要将接口拆分，使用多个隔离的接口。

