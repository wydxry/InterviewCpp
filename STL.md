## STL的基本组成部分
标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。
​广义上讲，STL分为3类：Algorithm（算法）、Container（容器）和Iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。
​详细的说，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。
标准模板库STL主要由6大组成部分：
1. 容器(Container)
​是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。
![STL的容器种类](/img/container.png)
2. 算法（Algorithm）
​是用来操作容器中的数据的模板函数。例如，STL用sort()来对一 个vector中的数据进行排序，用find()来搜索一个list中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。
3. 迭代器（Iterator）
​提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。 迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象;
4. 仿函数（Function object）
​仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。
5. 适配器（Adaptor）
简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。
6. 空间配制器（Allocator）
​为STL提供空间配置的系统。其中主要工作包括两部分：
（1）对象的创建与销毁；
（2）内存的获取与释放。

## Set的底层实现
set的特性是，所有元素都会根据元素的键值自动被排序。set的元素不像map那样可以同时拥有
实值（value）和键值(key)，set元素的键值就是实值，实值就是键值。set不允许两个元素具有
相同的键值。
set容器底层采用红黑树实现，红黑树为平衡二叉树的一种。
不同操作的时间复杂度近似为:
插入: O(logN)
查看: O(logN)
删除: O(logN)
unordered_set容器采用哈希表实现。
不同操作的时间复杂度为：
插入: O(1)，最坏情况O(N)
查看: O(1)，最坏情况O(N)
删除: O(1)，最坏情况O(N)

## map和unordered_map异同，增删时间复杂度
1. 需要引入的头文件不同
map: #include <map>
unordered_map: #include <unordered_map>
2. 内部实现机理不同
map: 红黑树 具有自动排序的功能，是非严格的二叉搜索树。map内部的所有元素都是有序的，使用中序遍历可将键值按照从小到大遍历出来。
unordered_map: 哈希表（也叫散列表，通过关键码值映射到Hash表中一个位置来访问记录，查找的复杂度是O(1)。 无序的 （海量数据广泛应用）。
3. 优缺点以及适用处
map：
优点：有序性，内部实现的红黑树的查找，插入和删除的复杂度都是O(logn),因此效率非常高。
缺点：空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点和红。黑性质，使得每一个节点都占用大量的空间。
适用：对于有顺序要求的问题，用map会高效一些。
unordered_map：
优点：因为内部实现哈希表，因此其查找速度非常快
缺点：哈希表的建立比较耗费时间，有可能还会哈希冲突（开链法避免地址冲突）
适用：常用于查找问题。

红黑树 VS AVL树
AVL是严格平衡，频繁插入和删除，会引起频繁的rebalance，导致效率降低；红黑树是弱平衡的，插入最多旋转2次，删除最多旋转3次，红黑树的查找，插入和删除的复杂度都是O(logn)。

## vector底层实现，空间不够怎么办，怎么分配128k的空间
vector底层实现的机制是一个动态数组，当其占用的内存不足时，就会自动分配时原来内存大小2倍的空间，并将原来内存中的数据拷贝到新开辟的内存中。vector扩容时，并不是在原有内存的基础上再分配一块内存，而是在其他的地方分配是原来内存大小2的空间，并将原来内存中的数据拷贝到新开辟的内存中，最后释放原来的内存。所以不会出现内存重叠的现象。
### 底层实现
Vector在堆中分配了一段连续的内存空间来存放元素。
包括三个迭代器，first 指向的是vector中对象的起始字节位置；last指向当前最后一个元素的末尾字节；end指向整个vector容器所占用内存空间的末尾字节。
### 扩容过程
如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。所以对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了；
### size()和capacity()
堆中分配内存，元素连续存放，内存空间只会增长不会减少。vector有两个函数，一个是capacity()，在不分配新内存下最多可以保存的元素个数，另一个size()，返回当前已经存储数据的个数。对于vector来说，capacity是永远大于等于size的，capacity和size相等时，vector就会扩容，capacity变大（翻倍）。
### resize()和reserve()
resize()：改变当前容器内含有元素的数量(size())，而不是容器的容量。
当resize(len)中len > capacity()，则数组中的size和capacity均设置为len；
当resize(len)中len <= capacity()，则数组中的size设置为len，而capacity不变;
reserve()：改变当前容器的最大容量（capacity）
如果reserve(len)中len >当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前的对象通过copy construtor复制过来，销毁之前的内存；
当reserve(len)中len<=当前的capacity()，则数组中的capacity不变，size不变，即不对容器做任何改变。
### 为什么要成倍的扩容而不是一次增加一个固定大小的容量呢？
采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度。
### 为什么是以两倍的方式扩容而不是三倍四倍，或者其他方式呢？
考虑可能产生的堆空间浪费，所以增长倍数不能太大，一般是1.5或2；GCC是2；VS是1.5
k = 2 每次扩展的新尺寸必然刚好大于之前分配的总和，之前分配的内存空间不可能被使用，这样对于缓存并不友好，采用1.5倍的增长方式可以更好的实现对内存的重复利用。
C++并没有规定扩容因子K，这是由标准库的实现者决定的。


