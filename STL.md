## STL的基本组成部分
标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。
​广义上讲，STL分为3类：Algorithm（算法）、Container（容器）和Iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。
​详细的说，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。
标准模板库STL主要由6大组成部分：
1. 容器(Container)
​是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。
![STL的容器种类](/img/container.png)
2. 算法（Algorithm）
​是用来操作容器中的数据的模板函数。例如，STL用sort()来对一 个vector中的数据进行排序，用find()来搜索一个list中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。
3. 迭代器（Iterator）
​提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。 迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象;
4. 仿函数（Function object）
​仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。
5. 适配器（Adaptor）
简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。
6. 空间配制器（Allocator）
​为STL提供空间配置的系统。其中主要工作包括两部分：
（1）对象的创建与销毁；
（2）内存的获取与释放。

## Set的底层实现
set的特性是，所有元素都会根据元素的键值自动被排序。set的元素不像map那样可以同时拥有
实值（value）和键值(key)，set元素的键值就是实值，实值就是键值。set不允许两个元素具有
相同的键值。
set容器底层采用红黑树实现，红黑树为平衡二叉树的一种。
不同操作的时间复杂度近似为:
插入: O(logN)
查看: O(logN)
删除: O(logN)
unordered_set容器采用哈希表实现。
不同操作的时间复杂度为：
插入: O(1)，最坏情况O(N)
查看: O(1)，最坏情况O(N)
删除: O(1)，最坏情况O(N)

## map和unordered_map异同，增删时间复杂度
1. 需要引入的头文件不同
map: #include <map>
unordered_map: #include <unordered_map>
2. 内部实现机理不同
map: 红黑树 具有自动排序的功能，是非严格的二叉搜索树。map内部的所有元素都是有序的，使用中序遍历可将键值按照从小到大遍历出来。
unordered_map: 哈希表（也叫散列表，通过关键码值映射到Hash表中一个位置来访问记录，查找的复杂度是O(1)。 无序的 （海量数据广泛应用）。
3. 优缺点以及适用处
map：
优点：有序性，内部实现的红黑树的查找，插入和删除的复杂度都是O(logn),因此效率非常高。
缺点：空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点和红。黑性质，使得每一个节点都占用大量的空间。
适用：对于有顺序要求的问题，用map会高效一些。
unordered_map：
优点：因为内部实现哈希表，因此其查找速度非常快
缺点：哈希表的建立比较耗费时间，有可能还会哈希冲突（开链法避免地址冲突）
适用：常用于查找问题。

红黑树 VS AVL树
AVL是严格平衡，频繁插入和删除，会引起频繁的rebalance，导致效率降低；红黑树是弱平衡的，插入最多旋转2次，删除最多旋转3次，红黑树的查找，插入和删除的复杂度都是O(logn)。

## vector底层实现，空间不够怎么办，怎么分配128k的空间
vector底层实现的机制是一个动态数组，当其占用的内存不足时，就会自动分配时原来内存大小2倍的空间，并将原来内存中的数据拷贝到新开辟的内存中。vector扩容时，并不是在原有内存的基础上再分配一块内存，而是在其他的地方分配是原来内存大小2的空间，并将原来内存中的数据拷贝到新开辟的内存中，最后释放原来的内存。所以不会出现内存重叠的现象。
### 底层实现
Vector在堆中分配了一段连续的内存空间来存放元素。
包括三个迭代器，first 指向的是vector中对象的起始字节位置；last指向当前最后一个元素的末尾字节；end指向整个vector容器所占用内存空间的末尾字节。
### 扩容过程
如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。所以对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了；
### size()和capacity()
堆中分配内存，元素连续存放，内存空间只会增长不会减少。vector有两个函数，一个是capacity()，在不分配新内存下最多可以保存的元素个数，另一个size()，返回当前已经存储数据的个数。对于vector来说，capacity是永远大于等于size的，capacity和size相等时，vector就会扩容，capacity变大（翻倍）。
### resize()和reserve()
resize()：改变当前容器内含有元素的数量(size())，而不是容器的容量。
当resize(len)中len > capacity()，则数组中的size和capacity均设置为len；
当resize(len)中len <= capacity()，则数组中的size设置为len，而capacity不变;
reserve()：改变当前容器的最大容量（capacity）
如果reserve(len)中len >当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前的对象通过copy construtor复制过来，销毁之前的内存；
当reserve(len)中len<=当前的capacity()，则数组中的capacity不变，size不变，即不对容器做任何改变。
### 为什么要成倍的扩容而不是一次增加一个固定大小的容量呢？
采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度。
### 为什么是以两倍的方式扩容而不是三倍四倍，或者其他方式呢？
考虑可能产生的堆空间浪费，所以增长倍数不能太大，一般是1.5或2；GCC是2；VS是1.5
k = 2 每次扩展的新尺寸必然刚好大于之前分配的总和，之前分配的内存空间不可能被使用，这样对于缓存并不友好，采用1.5倍的增长方式可以更好的实现对内存的重复利用。
C++并没有规定扩容因子K，这是由标准库的实现者决定的。


## set的实现原理
* set底层使用红黑树实现，一种高效的平衡检索二叉树。
* set容器中每一个元素就是二叉树的每一个节点，对于set容器的插入删除操作，效率都比较高，原因是二叉树的删除插入元素并不需要进行内存拷贝和内存移动，只是改变了指针的指向。 
* 对set进行插入删除操作 都不会引起迭代器的失效，因为迭代器相当于一个指针指向每一个二叉树的节点，对set的插入删除并不会改变原有内存中节点的改变。
* set中的元素都是唯一的，而且默认情况下会对元素进行升序排列。不能直接改变元素值，因为那样会打乱原本正确的顺序，要改变元素值必须先删除旧元素，再插入新元素。
* 不提供直接存取元素的任何操作函数，只能通过迭代器进行间接存取。

## map实现原理，各操作的时间复杂度是多少
1. map实现原理: 
* map 内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而 AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此 map 内部所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素。因此，对于 map 进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。
* map 中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值，使用中序遍历可将键值按照从小到大遍历出来。 
2. 各操作的时间复杂度 
* 插入: O(logN) 
* 查看: O(logN) 
* 删除: O(logN)

## deque的实现原理
1. deque是由一段一段的定量的连续空间构成。一旦有必要在 deque 前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在 deque 的头端或者尾端。
2. deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。
3. 既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。deque 采取一块所谓的 map（不是STL的map容器）作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素（此处成为一个结点）都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是 deque的存储空间的主体。
![deque](/img/deque.png)

## map和unordered_map的区别
map、unordered_map 是 C++ STL 中的两个容器，它们的区别有：
1. 导入的头文件 map：#include \<map> unordered_map：#include \<unordered_map> 
2. 原理及特点 map：内部实现了一个红黑树，该结构具有自动排序的功能，因此 map 内部的所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素，因此，对于 map 进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了 map 的效率。 unordered_map：内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。
3. map有序存储，底层是红黑树实现；unorderd_map无序存储，底层是哈希表实现。

