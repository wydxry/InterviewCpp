## 指针和引用的区别
1、引用概念上是定义一个变量的别名，而指针是存储一个变量的地址。

2、引用在定义时必须要初始化，但是指针没有要求。
 
3、引用在初始化时引用一个实体后，就不能再引用其他实体，因为其本质是一个指针常量，无法改变指向。而指针可以在任何时候指向任何一个同类型实体。
 
4、没有NULL引用，但有NULL指针。
 
5、在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是空地址空间所占字节个数（32位平台下占用4个字节，64位占用8字节）。

6、引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小。

7、有多级指针，但是没有多级引用。

8、访问实体方式不同，指针需要显示解引用，引用则由编译器自己处理。

9、引用比指针使用起来相对安全。

## C语言和C++的区别
1. C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多新特性，如引用、智能指针、auto变量等。
2. C++是面对对象的编程语言；C语言是面对过程的编程语言。
3. C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try—catch等等；
4. C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库更灵活、更通用。

## C++的三大特性
C++三大特性—封装、继承、多态。
封装目的是实现代码模块化。
继承目的是实现代码扩展。
多态目的是分为静态多态和动态多态。静态多态：函数重载和泛型编程。动态多态：虚函数重写。
一、封装
封装就是将数据和行为(或功能)有机结合起来，形成一个整体。把数据和处理数据的操作结合形成类，数据和函数都是类的成员。增强安全性和简化编程。对外隐藏实现细节暴露公共接口。外部通过接口来调用。
封装类的访问类型：
私有成员(private)，只有此类的成员函数才能访问。
保护成员(protected)，类和派生类的成员函数都能访问，但类外不阔以访问。
公有成员(public)，可以在类外访问。

特点：隔离变化，提高复用性，提高安全性。
缺点：封装太多，影响运行效率。使用者不知道代码的具体实现。

二、继承
继承就是A类被B类继承，A类为父类，B类为子类。B类继承Al类的所有公共和保护成员数据(属性)和成员函数(方法)。子类可以重新定义父类某些属性，重写父类的某些方法，即覆盖父类的某些属性和方法。使其获得与父类不同的功能。
优点：
1. 减少重复代码，增加复用性。
2. 让类与类之间产生关系，是多态的前提。
3. 增加了类与类之间的耦合性。
缺点：
1. 继承在编译时刻就定义了，无法时刻改变父类的继承实现。
2. 父类至少定义了子类的部分行为，父类改变可能影响子类的行为。
3. 如果继承下来的子类不适合解决新问题，必须重写或替换父类，这种依赖关系限制了灵活性。

三、多态
多态：一个接口多种实现状态。多态的出现大大提高了程序的扩展性。
动态多态，是基于封装和继承的来实现的，多个子类对继承于一个父类的虚函数进行重写，来实现不同状态。
静态多态分两种，一种在同一个作用域对函数进行重载(函数名相同，函数参数列表不同)，另一种是对函数进行模板化，忽略数据类型强调数据操作。

多态的体现：
父类引用或指针指向子类对象。
父类的引用或指针可以接受子类对象。

多态的前提：
必须存在父类与子类的继承关系。
父类中必须有虚函数。
子类必须重写父类的虚函数。
父类引用或指针指向子类对象。

多态的弊端：
易读性不好，调试困难。
模板只能定义在.h文件中，当工程大了后编译耗时。

## 虚继承，菱形继承


## 指针数组和数组指针的区别
指针数组里面装着指针，其实还是一个数组，定义形式为int *a[10]；
数组指针是指一个指向数组的指针，其实还是一个指针，只不过是指向数组而已，定义形式为int (*p)[10]。

## 虚函数
为了实现多态，目的是为了在父类指针指向不同子类对象时，调用虚函数，调用的是对应子类对象的成员函数，即可以自动识别具体子类对象。

## C++编译过程
1. 编辑（hello.c）
2. 预处理（把引用的文件展开，并生成hello.i的预处理文件）
3. 编译（把预处理编译成汇编语言文件）
4. 汇编（执行汇编语言文件）
5. 链接（把汇编语言文件链接组织起来成为可以执行的文件）

## 纯虚函数作用
纯虚函数是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。
纯虚函数也可以叫抽象函数，一般来说它只有函数名、参数和返回值类型，不需要函数体。这意味着它没有函数的实现，需要让派生类去实现。
C++中的纯虚函数，一般在函数签名后使用=0作为此类函数的标志。
Java、C#等语言中，则直接使用abstract作为关键字修饰这个函数签名，表示这是抽象函数(纯虚函数)。

## 虚函数总结
1. 纯虚函数声明如下： virtual void funtion1()=0;**纯虚函数一定没有定义**，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
2. 虚函数声明如下：virtual ReturnType FunctionName(Parameter) **虚函数必须实现**，如果不实现，编译器将报错，错误提示为：
error LNK****: unresolved external symbol "public: virtual void __thiscall ClassName::virtualFunctionName(void)"
3. 对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
4. 实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
5. 虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。
6. 在有动态分配堆上内存的时候，析构函数必须是虚函数(即必须回收内存)，但没有必要是纯虚的。
7. 友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。
8. 析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。

## 虚函数的底层原理
虚函数的用法：可以让派生类重写基类的成员函数实现多态。
虚函数实现多态的机制，严格来说是**动态多态**，是在出现运行的时候实现的。

虚函数的实现原理：每个虚函数都会有一个与之对应的**虚函数表**，该虚函数表的实质是一个**指针数组**，存放的是每一个对象的**虚函数入口地址**。对于一个派生类来说，他会继承基类的虚函数表同时增加自己的虚函数入口地址，如果派生类重写了基类的虚函数的话，那么继承过来的虚函数入口地址将被派生类的重写虚函数入口地址替代。那么在程序运行时会发生动态绑定，将父类指针绑定到实例化的对象实现多态。

## 虚函数表
C++中的虚函数的实现一般是通过虚函数表。
虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址。

## 简述一下 C++ 的重载和重写，以及它们的区别
### 重写
是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。
```C++
#include<bits/stdc++.h>
using namespace std;
class A
{
public:
    virtual void fun()
    {
        cout << "A";
    }
};
class B :public A
{
public:
    virtual void fun()
    {
        cout << "B";
    }
};
int main(void)
{
    A* a = new B();
    a->fun();//输出B，A类中的fun在B类中重写
}
```
### 重载
写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。
```C++
#include<bits/stdc++.h>
using namespace std;
class A
{
    void fun() {};
    void fun(int i) {};
    void fun(int i, int j) {};
    void fun1(int i,int j){};
};
```

## 构造函数有几种，分别什么作用
C++中的构造函数可以分为4类：默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。
1. 默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。
```C++
class Student
{
public:
    //默认构造函数
    Student()
    {
       num=1001;
       age=18;       
    }
    //初始化构造函数
    Student(int n,int a):num(n),age(a){}
private:
    int num;
    int age;
};
int main()
{
    //用默认构造函数初始化对象S1
    Student s1;
    //用初始化构造函数初始化对象S2
    Student s2(1002,18);
    return 0;
}
```
2. 拷贝构造函数
```C++
#include "stdafx.h"
#include "iostream.h"

class Test
{
    int i;
    int *p;
public:
    Test(int ai,int value)
    {
        i = ai;
        p = new int(value);
    }
    ~Test()
    {
        delete p;
    }
    Test(const Test& t)
    {
        this->i = t.i;
        this->p = new int(*t.p);
    }
};
//复制构造函数用于复制本类的对象
int main(int argc, char* argv[])
{
    Test t1(1,2);
    Test t2(t1);//将对象t1复制给t2。注意复制和赋值的概念不同
    return 0;
}
```
赋值构造函数默认实现的是值拷贝（浅拷贝）。
3. 移动构造函数。用于将其他类型的变量，隐式转换为本类对象。下面的转换构造函数，将int类型的r转换为Student类型的对象，对象的age为r，num为1004.
```
Student(int r)
{
    int num=1004；
    int age= r；
}
```

