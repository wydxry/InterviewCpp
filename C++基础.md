## 指针和引用的区别
1、引用概念上是定义一个变量的别名，而指针是存储一个变量的地址。

2、引用在定义时必须要初始化，但是指针没有要求。
 
3、引用在初始化时引用一个实体后，就不能再引用其他实体，因为其本质是一个指针常量，无法改变指向。而指针可以在任何时候指向任何一个同类型实体。
 
4、没有NULL引用，但有NULL指针。
 
5、在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是空地址空间所占字节个数（32位平台下占用4个字节，64位占用8字节）。

6、引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小。

7、有多级指针，但是没有多级引用。

8、访问实体方式不同，指针需要显示解引用，引用则由编译器自己处理。

9、引用比指针使用起来相对安全。

## C语言和C++的区别
1. C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多新特性，如引用、智能指针、auto变量等。
2. C++是面对对象的编程语言；C语言是面对过程的编程语言。
3. C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try—catch等等；
4. C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库更灵活、更通用。

## C++的三大特性
C++三大特性—封装、继承、多态。
封装目的是实现代码模块化。
继承目的是实现代码扩展。
多态目的是分为静态多态和动态多态。静态多态：函数重载和泛型编程。动态多态：虚函数重写。
一、封装
封装就是将数据和行为(或功能)有机结合起来，形成一个整体。把数据和处理数据的操作结合形成类，数据和函数都是类的成员。增强安全性和简化编程。对外隐藏实现细节暴露公共接口。外部通过接口来调用。
封装类的访问类型：
私有成员(private)，只有此类的成员函数才能访问。
保护成员(protected)，类和派生类的成员函数都能访问，但类外不阔以访问。
公有成员(public)，可以在类外访问。

特点：隔离变化，提高复用性，提高安全性。
缺点：封装太多，影响运行效率。使用者不知道代码的具体实现。

二、继承
继承就是A类被B类继承，A类为父类，B类为子类。B类继承Al类的所有公共和保护成员数据(属性)和成员函数(方法)。子类可以重新定义父类某些属性，重写父类的某些方法，即覆盖父类的某些属性和方法。使其获得与父类不同的功能。
优点：
1. 减少重复代码，增加复用性。
2. 让类与类之间产生关系，是多态的前提。
3. 增加了类与类之间的耦合性。
缺点：
1. 继承在编译时刻就定义了，无法时刻改变父类的继承实现。
2. 父类至少定义了子类的部分行为，父类改变可能影响子类的行为。
3. 如果继承下来的子类不适合解决新问题，必须重写或替换父类，这种依赖关系限制了灵活性。

三、多态
多态：一个接口多种实现状态。多态的出现大大提高了程序的扩展性。
动态多态，是基于封装和继承的来实现的，多个子类对继承于一个父类的虚函数进行重写，来实现不同状态。
静态多态分两种，一种在同一个作用域对函数进行重载(函数名相同，函数参数列表不同)，另一种是对函数进行模板化，忽略数据类型强调数据操作。

多态的体现：
父类引用或指针指向子类对象。
父类的引用或指针可以接受子类对象。

多态的前提：
必须存在父类与子类的继承关系。
父类中必须有虚函数。
子类必须重写父类的虚函数。
父类引用或指针指向子类对象。

多态的弊端：
易读性不好，调试困难。
模板只能定义在.h文件中，当工程大了后编译耗时。

## 虚继承，菱形继承


## 指针数组和数组指针的区别
指针数组里面装着指针，其实还是一个数组，定义形式为int *a[10]；
数组指针是指一个指向数组的指针，其实还是一个指针，只不过是指向数组而已，定义形式为int (*p)[10]。

## 虚函数
为了实现多态，目的是为了在父类指针指向不同子类对象时，调用虚函数，调用的是对应子类对象的成员函数，即可以自动识别具体子类对象。

## C++编译过程
1. 编辑（hello.c）
2. 预处理（把引用的文件展开，并生成hello.i的预处理文件）
3. 编译（把预处理编译成汇编语言文件）
4. 汇编（执行汇编语言文件）
5. 链接（把汇编语言文件链接组织起来成为可以执行的文件）

## 纯虚函数作用
纯虚函数是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。
纯虚函数也可以叫抽象函数，一般来说它只有函数名、参数和返回值类型，不需要函数体。这意味着它没有函数的实现，需要让派生类去实现。
C++中的纯虚函数，一般在函数签名后使用=0作为此类函数的标志。
Java、C#等语言中，则直接使用abstract作为关键字修饰这个函数签名，表示这是抽象函数(纯虚函数)。

## 虚函数总结
1. 纯虚函数声明如下： virtual void funtion1()=0;**纯虚函数一定没有定义**，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
2. 虚函数声明如下：virtual ReturnType FunctionName(Parameter) **虚函数必须实现**，如果不实现，编译器将报错，错误提示为：
error LNK****: unresolved external symbol "public: virtual void __thiscall ClassName::virtualFunctionName(void)"
3. 对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
4. 实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
5. 虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。
6. 在有动态分配堆上内存的时候，析构函数必须是虚函数(即必须回收内存)，但没有必要是纯虚的。
7. 友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。
8. 析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。

## 虚函数的底层原理
虚函数的用法：可以让派生类重写基类的成员函数实现多态。
虚函数实现多态的机制，严格来说是**动态多态**，是在出现运行的时候实现的。

虚函数的实现原理：每个虚函数都会有一个与之对应的**虚函数表**，该虚函数表的实质是一个**指针数组**，存放的是每一个对象的**虚函数入口地址**。对于一个派生类来说，他会继承基类的虚函数表同时增加自己的虚函数入口地址，如果派生类重写了基类的虚函数的话，那么继承过来的虚函数入口地址将被派生类的重写虚函数入口地址替代。那么在程序运行时会发生动态绑定，将父类指针绑定到实例化的对象实现多态。

## 虚函数表
C++中的虚函数的实现一般是通过虚函数表。
虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址。

## 简述一下 C++ 的重载和重写，以及它们的区别
### 重写
是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。
```C++
#include<bits/stdc++.h>
using namespace std;
class A
{
public:
    virtual void fun()
    {
        cout << "A";
    }
};
class B :public A
{
public:
    virtual void fun()
    {
        cout << "B";
    }
};
int main(void)
{
    A* a = new B();
    a->fun();//输出B，A类中的fun在B类中重写
}
```
### 重载
写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。
```C++
#include<bits/stdc++.h>
using namespace std;
class A
{
    void fun() {};
    void fun(int i) {};
    void fun(int i, int j) {};
    void fun1(int i,int j){};
};
```

## 构造函数有几种，分别什么作用
C++中的构造函数可以分为4类：默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数。
1. 默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。
```C++
class Student
{
public:
    //默认构造函数
    Student()
    {
       num=1001;
       age=18;       
    }
    //初始化构造函数
    Student(int n,int a):num(n),age(a){}
private:
    int num;
    int age;
};
int main()
{
    //用默认构造函数初始化对象S1
    Student s1;
    //用初始化构造函数初始化对象S2
    Student s2(1002,18);
    return 0;
}
```
2. 拷贝构造函数
```C++
#include "stdafx.h"
#include "iostream.h"

class Test
{
    int i;
    int *p;
public:
    Test(int ai,int value)
    {
        i = ai;
        p = new int(value);
    }
    ~Test()
    {
        delete p;
    }
    Test(const Test& t)
    {
        this->i = t.i;
        this->p = new int(*t.p);
    }
};
//复制构造函数用于复制本类的对象
int main(int argc, char* argv[])
{
    Test t1(1,2);
    Test t2(t1);//将对象t1复制给t2。注意复制和赋值的概念不同
    return 0;
}
```
赋值构造函数默认实现的是值拷贝（浅拷贝）。
3. 移动构造函数。用于将其他类型的变量，隐式转换为本类对象。下面的转换构造函数，将int类型的r转换为Student类型的对象，对象的age为r，num为1004.
```
Student(int r)
{
    int num=1004；
    int age= r；
}
```

## C++中智能指针和指针的区别是什么？
### 智能指针 
如果在程序中使用 new 从堆（自由存储区）分配内存，等到不需要时，应使用 delete 将其释放。C++ 引入了智能指针 auto_ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL）表明，需要有更精致的机制。基于程序员的编程体验和 BOOST 库提供的解决方案，C++11 摒弃了 auto_ptr，并新增了三种智能指针：unique_ptr、shared_ptr 和 weak_ptr。所有新增的智能指针都能与 STL 容器和移动语义协同工作。 
### 指针 
C语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存单元。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。 
### 智能指针和普通指针的区别
在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。指针是一种数据类型，用于保存内存地址，而智能指针是类模板。

## C++11中的可变参数模板新特性
在C++11之前，类模板和函数模板只能含有固定数量的模板参数。

C++11增强了模板功能，它对参数进行了高度泛化，允许模板定义中包含0到任意个、任意类型的模板参数，这就是可变参数模板。可变参数模板的加入使得C++11的功能变得更加强大，能够很有效的提升灵活性。 
1. 可变参数函数模板语法： 
```C++
template<typename... t=""> void fun(T...args) { 
    // 函数体 
} 
```
模板参数中，typename（或者 class）后跟...就表明T是一个可变模板参数，它可以接收多种数据类型，又称模板参数包。fun()函数中，args 参数的类型用T...表示，表示args参数可以接收任意个参数，又称函数参数包。
2. 可变参数类模板语法： 
```C++
template <typename... types=""> class test; 
```
3. 展开参数包的方式 
- 可变参数函数模板可以采用递归方式、逗号表达式 + 初始化列表的方式展开参数包； 
- 可变参数类模板可以采用递归+继承的方式展开参数包。 
C++11标准提供的tuple元组类就是一个典型的可变参数模板类，它的定义如下：
```C++
 template <typename... types=""> class tuple;</typename...></typename...></typename...>
```

## 虚析构函数有什么作用
虚析构函数，是将基类的析构函数声明为 
```C++
virtual class Base { 
    public: Base() {} 
    // 虚析构函数
    virtual ~Base() {} 
}
```
主要作用是为了防止遗漏资源的释放，**防止内存泄露**。如果基类中的析构函数没有声明为虚函数，基类指针指向派生类对象时，则当基类指针释放时不会调用派生类对象的析构函数，而是**调用基类的析构函数**，如果派生类析构函数中做了某些释放资源的操作，则这时就会**造成内存泄露**。

## auto 和 decltype 如何使用
C++11 提供了多种简化声明的功能，尤其在使用模板时。 
1. auto 实现自动类型推断，要求进行显示初始化，让编译器能够将变量的类型设置为初始值的类型： 
```C++
auto a = 12; 
auto pt = &a; 
double fm(double a, int b) { 
    return a + b; 
} 
auto pf = fm; 
```
简化模板声明 
```C++
for(std::initializer_list<double>::iterator p = il.begin(); p != il.end(); p++) 
for(auto p = il.begin(); p != il.end(); p++) 
```
2. decltype decltype 将变量的类型声明为表达式指定的类型。 
```C++
decltype(expression) var; 
decltype(x) y; // 让y的类型与x相同，x是一个表达式 
double x; 
int n; 
decltype(x*n) q; 
decltype(&x) pd; 
template<typename t=""> 
void ef(T t, U u) { 
    decltype(T*U) tu; 
}
```

## 左值、右值、左值引用、右值引用、右值引用的使用场景
1. **左值**:在C++中可以取地址的、有名字的就是左值 int a = 10; // 其中 a 就是左值 
2. **右值**:不能取地址的、没有名字的就是右值 int a = 10; // 其中 10 就是右值右值 
3. **左值引用**:左值引用就是对一个左值进行引用。传统的C++引用（现在称为左值引用）使得标识符关联到左值。左值是一个表示数据的表达式（如变量名或解除引用的指针），程序可获取其地址。最初，左值可出现在赋值语句的左边，但修饰符const的出现使得可以声明这样的标识符，即不能给它赋值，但可获取其地址： int n; int * pt = new int; const int b = 101; int & rn = n; int & rt = *pt; const int & rb = b; const int & rb = 10; 
4. **右值引用**:右值引用就是对一个右值进行引用。C++11新增了右值引用（rvalue reference），这种引用可指向右值（即可出现在赋值表达式右边的值），但不能对其应用地址运算符。右值包括字面常量（C-风格字符串除外，它表示地址）、诸如 x + y 等表达式以及返回值的函数（条件是该函数返回的不是引用），右值引用使用 && 声明： int x = 10; int y = 23; int && r1 = 13; int && r2 = x + y; double && r3 = std::sqrt(2.0); 
5. 右值引用的使用场景:右值引用可以实现**移动语义**、**完美转发**。

## 内联函数和函数的区别，内联函数的作用
1. 内联函数和函数的区别： 
- 内联函数比普通函数多了关键字 inline； 
- 内联函数避免了函数调用的开销；普通函数有调用的开销； 
- 普通函数在被调用的时候，需要寻址（函数入口地址）；**内联函数不需要寻址**； 
- 内联函数有一定的限制，内联函数体**要求代码简单，不能包含复杂的结构控制语句**，如果内联函数函数体过于复杂，编译器将自动把内联函数当成普通函数来执行；普通函数没有这个要求。 
2. 内联函数的作用： 因为函数调用时候**需要创建时间、参数传入传递等操作**，**造成了时间和空间的额外开销**。通过编译器预处理，在调用内联函数的地方将内联函数内的语句复制到调用函数的地方，也就是**直接展开代码执行**，从而提高了效率，减少了一些不必要的开销。同时内联函数还能解决宏定义的问题。

## 指针和引用的区别
1. 定义和性质不同。指针是一种数据类型，用于保存地址类型的数据，而引用可以看成是变量的别名。指针定义格式为：数据类型 *；而引用的定义格式为：数据类型 &； 
2. 引用不可以为空，当被创建的时候必须初始化，而指针变量可以是空值，在任何时候初始化； 
3. 指针可以有多级，但引用只能是一级； 
4. 引用使用时无需解引用（*），指针需要解引用； 
5. 指针变量的值可以是 NULL，而引用的值不可以为 NULL； 
6. 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了； 
7. sizeof 引用得到的是所指向的变量（对象）的大小，而 sizeof 指针得到的是指针变量本身的大小； 
8. 指针作为函数参数传递时传递的是指针变量的值，而引用作为函数参数传递时传递的是实参本身，而不是拷贝副本； 
9. 指针和引用进行++运算意义不一样。

## const 和 define 的区别
const 在 C 语言中表示只读，编译器禁止对它修饰的变量进行修改，在 C++ 中增加了常量的语义。

而 define 用于定义宏，而宏也可以用于定义常量。

它们的区别有：
1. const 生效于编译阶段，而 define 生效于预处理阶段；
2. define只是简单的字符串替换，没有类型检查，而 const 有对应的数据类型，编译器要进行判断的，可以避免一些低级的错误；
3. 用 define 定义的常量是不可以用指针变量去指向的，用 const 定义的常量是可以用指针去指向该常量的地址的；
4. define 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大，const 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝；
5. 可以对 const 常量进行调试，但是不能对宏常量进行调试。

## delete 和 free 的区别
1. delete 是操作符，而 free 是函数；
2. delete 用于释放 new 分配的空间，free 有用释放 malloc 分配的空间；
3. free 不会调用对象的析构函数，而 delete 会调用对象的析构函数；
4. 调用 free 之前需要检查要释放的指针是否为 NULL，使用 delete 释放内存则不需要检查指针是否为 NULL。

## C++ 中的内存对齐
1. 什么是内存对齐 现代计算机中内存空间都是按照 字节（byte）划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会**要求这些数据的首地址的值是某个数 k（通常它为4或8）的倍数**，这就是所谓的内存对齐。 
2. 内存对齐的**原因**
- 平台原因（移植原因）：**不是所有的硬件平台都能访问任意地址上的任意数据的**。某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 
- 性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问，而**对齐的内存访问仅需要一次访问**。 
3. 内存对齐的**规则** 
- 每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。可以通过预编译命令 #pragma pack(n)，n = 1,2,4,8,16 来改变这一系数。
- 有效对其值：是给定值 #pragma pack(n) 和结构体中最长数据类型长度中较小的那个，有效对齐值也叫对齐单位。 
- 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。 
- **结构体的总大小为有效对齐值的整数倍**，如有需要编译器会在最末一个成员之后加上填充字节。

## auto 和 decltype 如何使用

## C++中函数指针和指针函数的区别
1. 定义不同

指针函数本质是一个函数，其返回值为指针。

函数指针本质是一个指针，其指向一个函数。

2. 写法不同

指针函数：int *fun(int x,int y);

函数指针：int (*fun)(int x,int y);

3. 用法不同
```C++
//指针函数示例
typedef struct _Data{
    int a;
    int b;
}Data;

//指针函数
Data* f(int a,int b){
    Data * data = new Data;
    //...
    return data;
}

int main(){
    //调用指针函数
    Data * myData = f(4,5);
    //Data * myData = static_cast<Data*>(f(4,5));
   //...
}

//函数指针示例
int add(int x,int y){
    return x + y;
}
//函数指针
int (*fun)(int x,int y);
//赋值
fun = add;
//调用
cout << "(*fun)(1,2) = " << (*fun)(1,2) ;
//输出结果
//(*fun)(1,2) =  3
```
## 说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。
```C++
const int a;     //指的是a是一个常量，不允许修改。
const int *a;    //a指针所指向的内存里的值不变，即（*a）不变
int const *a;    //同const int *a;
int *const a;    //a指针所指向的内存地址不变，即a不变
const int *const a;   //都不变，即（*a）不变，a也不变
```

## 说说const和define的区别
const用于定义常量；而define用于定义宏，而宏也可以用于定义常量。

都用于常量定义时，它们的区别有：
1. const生效于编译的阶段；define生效于预处理阶段。
2. const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。
3. const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。

