## 指针和引用的区别
1、引用概念上是定义一个变量的别名，而指针是存储一个变量的地址。

2、引用在定义时必须要初始化，但是指针没有要求。
 
3、引用在初始化时引用一个实体后，就不能再引用其他实体，因为其本质是一个指针常量，无法改变指向。而指针可以在任何时候指向任何一个同类型实体。
 
4、没有NULL引用，但有NULL指针。
 
5、在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是空地址空间所占字节个数（32位平台下占用4个字节，64位占用8字节）。

6、引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小。

7、有多级指针，但是没有多级引用。

8、访问实体方式不同，指针需要显示解引用，引用则由编译器自己处理。

9、引用比指针使用起来相对安全。

## C语言和C++的区别
1、C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多新特性，如引用、智能指针、auto变量等。

2、C++是面对对象的编程语言；C语言是面对过程的编程语言。

3、C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try—catch等等；

4、C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库更灵活、更通用。

## C++的三大特性
C++三大特性—封装、继承、多态。
封装目的是实现代码模块化。
继承目的是实现代码扩展。
多态目的是分为静态多态和动态多态。静态多态：函数重载和泛型编程。动态多态：虚函数重写。
一、封装
封装就是将数据和行为(或功能)有机结合起来，形成一个整体。把数据和处理数据的操作结合形成类，数据和函数都是类的成员。增强安全性和简化编程。对外隐藏实现细节暴露公共接口。外部通过接口来调用。
封装类的访问类型：
私有成员(private)，只有此类的成员函数才能访问。
保护成员(protected)，类和派生类的成员函数都能访问，但类外不阔以访问。
公有成员(public)，可以在类外访问。

特点：隔离变化，提高复用性，提高安全性。
缺点：封装太多，影响运行效率。使用者不知道代码的具体实现。

二、继承
继承就是A类被B类继承，A类为父类，B类为子类。B类继承Al类的所有公共和保护成员数据(属性)和成员函数(方法)。子类可以重新定义父类某些属性，重写父类的某些方法，即覆盖父类的某些属性和方法。使其获得与父类不同的功能。
优点：
1、减少重复代码，增加复用性。
2、让类与类之间产生关系，是多态的前提。
3、增加了类与类之间的耦合性。
缺点：
1、继承在编译时刻就定义了，无法时刻改变父类的继承实现。
2、父类至少定义了子类的部分行为，父类改变可能影响子类的行为。
3、如果继承下来的子类不适合解决新问题，必须重写或替换父类，这种依赖关系限制了灵活性。

三、多态
多态：一个接口多种实现状态。多态的出现大大提高了程序的扩展性。
动态多态，是基于封装和继承的来实现的，多个子类对继承于一个父类的虚函数进行重写，来实现不同状态。
静态多态分两种，一种在同一个作用域对函数进行重载(函数名相同，函数参数列表不同)，另一种是对函数进行模板化，忽略数据类型强调数据操作。

多态的体现：
父类引用或指针指向子类对象。
父类的引用或指针可以接受子类对象。

多态的前提：
必须存在父类与子类的继承关系。
父类中必须有虚函数。
子类必须重写父类的虚函数。
父类引用或指针指向子类对象。

多态的弊端：
易读性不好，调试困难。
模板只能定义在.h文件中，当工程大了后编译耗时。

## 虚继承，菱形继承


## 指针数组和数组指针的区别
指针数组里面装着指针，其实还是一个数组，定义形式为int *a[10]；
数组指针是指一个指向数组的指针，其实还是一个指针，只不过是指向数组而已，定义形式为int (*p)[10]。

## 虚函数
为了实现多态，目的是为了在父类指针指向不同子类对象时，调用虚函数，调用的是对应子类对象的成员函数，即可以自动识别具体子类对象。

## C++编译过程
1、编辑（hello.c）
2、预处理（把引用的文件展开，并生成hello.i的预处理文件）
3、编译（把预处理编译成汇编语言文件）
4、汇编（执行汇编语言文件）
5、链接（把汇编语言文件链接组织起来成为可以执行的文件）

## 纯虚函数作用
纯虚函数是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。
纯虚函数也可以叫抽象函数，一般来说它只有函数名、参数和返回值类型，不需要函数体。这意味着它没有函数的实现，需要让派生类去实现。
C++中的纯虚函数，一般在函数签名后使用=0作为此类函数的标志。
Java、C#等语言中，则直接使用abstract作为关键字修饰这个函数签名，表示这是抽象函数(纯虚函数)。

## 虚函数总结
1. 纯虚函数声明如下： virtual void funtion1()=0;**纯虚函数一定没有定义**，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
2. 虚函数声明如下：virtual ReturnType FunctionName(Parameter) **虚函数必须实现**，如果不实现，编译器将报错，错误提示为：
error LNK****: unresolved external symbol "public: virtual void __thiscall ClassName::virtualFunctionName(void)"
3. 对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
4. 实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
5. 虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。
6. 在有动态分配堆上内存的时候，析构函数必须是虚函数(即必须回收内存)，但没有必要是纯虚的。
7. 友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。
8. 析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。

