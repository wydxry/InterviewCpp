## 红黑树
### 有了二叉搜索树，为什么还需要平衡二叉树？
在学习二叉搜索树、平衡二叉树时，我们不止一次提到，二叉搜索树容易退化成一条链
这时，查找的时间复杂度从O(log2N)也将退化成O(N)
引入对左右子树高度差有限制的平衡二叉树，保证查找操作的最坏时间复杂度也为O(log2N)
### 有了平衡二叉树，为什么还需要红黑树？
AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡
在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣
红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，整体性能优于AVL
红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决
红黑树的红黑规则，保证最坏的情况下，也能在O(log2N)时间内完成查找操作。
### 红黑规则
节点不是黑色，就是红色（非黑即红）
根节点为黑色
叶节点为黑色（叶节点是指末梢的空节点 Nil或Null）
一个节点为红色，则其两个子节点必须是黑色的（根到叶子的所有路径，不可能存在两个连续的红色节点）
每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同的黑色高度）
### 红黑树的应用
Java中，TreeMap、TreeSet都使用红黑树作为底层数据结构
JDK 1.8开始，HashMap也引入了红黑树：当冲突的链表长度超过8时，自动转为红黑树
Linux底层的CFS进程调度算法中，vruntime使用红黑树进行存储
多路复用技术的Epoll，其核心结构是红黑树 + 双向链表
C++中，set和map都使用了红黑树作为底层数据结构

### 红黑树的重要知识点

从二叉搜索树 → AVL，严格控制左右子树高度差，避免二叉搜索树退化成链表（时间复杂度从O(log 2N) 退化成O(N)
从AVL → 红黑树，牺牲严格的平衡要求，以换取新增/删除节点时少量的旋转操作，平均性能优于AVL；通过红黑规则，保证在最坏的情况下，也能拥有O(log 2N)的时间复杂度

红黑规则
红黑树节点的定义、红黑树的定义、红黑树的左旋、右旋操作
红黑树新增节点后的调整，记住左儿子的情况，举一反三右儿子的情况
红黑树删除节点后的调整，记住左儿子的情况，举一反三右儿子的情况