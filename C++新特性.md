## C++11 的新特性有哪些
C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：
**语法的改进**
（1）统一的初始化方法
（2）成员变量默认初始化
好处：构建一个类的对象不需要用构造函数初始化成员变量。
```C++
//程序实例
#include<iostream>
using namespace std;
class B
{
public:
    int m = 1234; //成员变量有一个初始值
    int n;
};
int main()
{
    B b;
    cout << b.m << endl;
    return 0;
}
```
（3）auto关键字 用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）
（4）decltype 求表达式的类型
（5）智能指针 shared_ptr
（6）空指针 nullptr（原来NULL）
（7）基于范围的for循环
（8）右值引用和move语义 让程序员有意识减少进行深拷贝操作
**标准库扩充（往STL里新加进一些模板类，比较好用）**
（9）无序容器（哈希表） 用法和功能同map一模一样，区别在于哈希表的效率更高
（10）正则表达式 可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串
（11）Lambda表达式

## 说说 C++ 中智能指针和指针的区别是什么？
### 智能指针
如果在程序中使用new从堆（自由存储区）分配内存，等到不需要时，应使用delete将其释放。C++引用了智能指针auto_ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL）表明，需要有更精致的机制。基于程序员的编程体验和BOOST库提供的解决方案，C++11摒弃了auto_ptr，并新增了三种智能指针：unique_ptr、shared_ptr和weak_ptr。所有新增的智能指针都能与STL容器和移动语义协同工作。

### 指针
​C 语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存单元。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。

### 智能指针和普通指针的区别
智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。

## 说说 C++中的智能指针有哪些？分别解决的问题以及区别？
### 有哪些智能指针
C++中的智能指针有4种，分别为：**shared_ptr**、**unique_ptr**、**weak_ptr**、**auto_ptr**，其中auto_ptr被C++11弃用。

### 使用智能指针的原因
​申请的空间（即new出来的空间），在使用结束时，需要delete掉，否则会形成内存碎片。在程序运行期间，new出来的对象，在析构函数中delete掉，但是这种方法不能解决所有问题，因为有时候new发生在某个全局函数里面，该方法会给程序员造成精神负担。此时，智能指针就派上了用场。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，**避免了手动释放内存空间**。

### 四种指针分别解决的问题以及各自特性如下
### 1.auto_ptr（C++98的方案，C++11已经弃用）

### 2.unique_ptr（替换auto_ptr）​
unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露。

### 3.shared_ptr（非常好使）
​shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。

​shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。

### 4.weak_ptr
​weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。

weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

## C++11 中四种类型转换
​C++中四种类型转换分别为const_cast、static_cast、dynamic_cast、reinterpret_cast，四种转换功能分别如下：

1. const_cast
​
将const变量转为非const

2. static_cast

静态转换（完全依赖编译期信息，可以认为是编译时评估的），也就是在编译期间转换，转换失败的话会抛出一个编译错误。没有运行时类型检查。

一般来说，编译器可以隐式转换的，都可以用static_cast进行显式转换。

- 类层次结构中的基类和子类之间指针或引用的转换：
    * 进行上行转换（把子类的指针或引用转换成基类表示）是安全的；

    * 进行下行转换（把基类指针或引用转换成子类指针或引用）时，由于没有动态类型检查，所以是不安全的（得用dynamic_cast）。
- 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
- void指针和目标类型指针间的互相转换，例如void *转int *、char *转void *等。

注意事项：

- 大精度转换为小精度的会造成截断处理，损失精度；
由于没有动态类型检查，所以多态的向下转换是不安全的。
- 不能用于两个具体类型指针之间的转换，例如int *转double *、Student *转int *等。
- 不同类型的数据存储格式不一样，长度也不一样，用 A 类型的指针指向 B 类型的数据后，会按照 A 类型的方式来处理数据：如果是读取操作，可能会得到一堆没有意义的值；如果是写入操作，可能会使 B 类型的数据遭到破坏，当再次以 B 类型的方式读取数据时会得到一堆没有意义的值。
- 不能用于int 和指针之间的转换。将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件。

​最常用，可以用于各种隐式转换，比如非const转const，static_cast可以用于类向上转换，但向下转换能成功但是不安全。

3. dynamic_cast

​只能用于**含有虚函数的类转换**，用于类向上和向下转换

**​向上转换**：指子类向基类转换。

​**向下转换**：指基类向子类转换。

​这两种转换，子类包含父类，当父类转换成子类时可能出现非法内存访问的问题。

​dynamic_cast通过判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。dynamic_cast可以做类之间上下转换，转换的时候会进行类型检查，类型相等成功转换，类型不等转换失败。运用RTTI技术，RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。在c++层面主要体现在dynamic_cast和typeid，vs中虚函数表的-1位置存放了指向type_info的指针，对于存在虚函数的类型，dynamic_cast和typeid都会去查询type_info。

4. reinterpret_cast

reinterpret 是“重新解释”的意思，顾名思义，reinterpret_cast 这种转换仅仅是对二进制位的重新解释(可以理解为无关类型底层的内存强制转换)，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。

​reinterpret_cast可以做任何类型的转换，不过不对转换结果保证，容易出问题。

注意：为什么不用C的强制转换：C的强制转换表面上看起来功能强大什么都能转，但是转换不够明确，不能进行错误检查，容易出错。




