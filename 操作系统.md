## 操作系统中的内存管理
操作系统内存管理：物理内存管理和虚拟内存管理。

物理内存管理：程序装入等概念、交换技术、连续分配管理方式和非连续分配管理方式（分页、分段、段页式）。

虚拟内存管理：虚拟内存管理包括虚虚拟内存概念、请求分页管理方式、页面置换算法、页面分配策略、工作集和抖动。

## Linux中fork函数的作用
fork函数用来创建一个子进程。
fork()函数，其原型如下：
```C++
#include <unistd.h>  
pid_t fork(void);  
```
fork()函数不需要参数，返回值是一个进程标识符PID。返回值有以下三种情况：
（1） 对于父进程，fork()函数返回新创建的子进程的PID。
（2） 对于子进程，fork()函数调用成功会返回0。
（3） 如果创建出错，fork()函数返回-1。

fork()函数创建一个新进程后，会为这个新进程分配进程空间，将父进程的进程空间中的内容复制到子进程的进程空间中，包括父进程的数据段和堆栈段，并且和父进程共享代码段。这时候，子进程和父进程一模一样，都接受系统的调度。因为两个进程都停留在fork()函数中，最后fork()函数会返回两次，一次在父进程中返回，一次在子进程中返回，两次返回的值不一样，如上面的三种情况。

## 伙伴系统


## 进程和线程相比，为什么慢？
1. 进程系统开销显著大于线程开销；线程需要的系统资源更少。
2. 进程切换开销比线程大。多进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈；多线程切换时只需要切换硬件上下文和内核栈。
3. 进程通信比线程通信开销大。进程通信需要借助管道、队列、共享内存，需要额外申请空间，通信繁琐；而线程共享进程的内存，如代码段、数据段、扩展段，通信快捷简单，同步开销更小。

## 简述Linux零拷贝的原理？
所谓「零拷贝」描述的是计算机操作系统当中，CPU不执行将数据从一个内存区域，拷贝到另外一个内存区域的任务。通过网络传输文件时，这样通常可以节省 CPU 周期和内存带宽。
### 零拷贝的好处
1. 节省了 CPU 周期，空出的 CPU 可以完成更多其他的任务
2. 减少了内存区域之间数据拷贝，节省内存带宽
3. 减少用户态和内核态之间数据拷贝，提升数据传输效率
4. 应用零拷贝技术，减少用户态和内核态之间的上下文切换
### 零拷贝原理

## 简述epoll和select的区别，epoll为什么高效？
### 区别
1. 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；而epoll保证了每个fd在整个过程中只会拷贝一次。
2. 每次调用select都需要在内核遍历传递进来的所有fd；而epoll只需要轮询一次fd集合，同时查看就绪链表中有没有就绪的fd就可以了。
3. select支持的文件描述符数量太小了，默认是1024；而epoll没有这个限制，它所支持的fd上限是最大可以打开文件的数目，这个数字一般远大于2048。
### epoll为什么高效
1. select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。
2. select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而epoll只要一次拷贝，而且把当前进程往等待队列上挂也只挂一次，这也能节省不少的开销。

## 说说多路IO复用技术有哪些，区别是什么？
select，poll，epoll都是IO多路复用的机制，I/O多路复用就是通过一种机制，可以**监视多个文件描述符**，一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。
### 区别
1. poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。
2. select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。
3. select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而epoll只要一次拷贝，而且把当前进程往等待队列上挂也只挂一次，这也能节省不少的开销。

## 死锁定义及发生的条件
### 死锁的定义:
两个或两个以上的进程在执行过程中,因争夺共享资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。 
### 产生死锁的必要条件:
1. 互斥条件：指进程对所分配到的资源进行排它性使用,即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源,则请求者只能等待,直至占有资源的进程用毕释放； 
2. 请求和保持条件：指进程已经保持至少一个资源,但又提出了新的资源请求,而该资源已被其它进程占有,此时请求进程阻塞,但又对自己已获得的其它资源保持不放； 
3. 不剥夺条件：指进程已获得的资源,在未使用完之前,不能被剥夺,只能在使用完时由自己释放；
4. 环路等待条件：指在发生死锁时,必然存在一个进程——资源的环形链,即进程集合 {P0,P1,P2,···,Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源,……,Pn 正在等待已被 P0 占用的资源。

## 内存管理
内存管理主要包括内存的**分配（malloc）**和**释放（free）**，内存的分配可以分为**连续内存分配**和**非连续内存分配**。

**连续分配**：为用户分配一个连续的内存空间，常见的连续分配如块式管理。

**非连续分配**又分为页式存储管理，段式存储管理和段页数存储管理。

* 页式存储管理：页是数据分配的物理单位，页分配是为了实现数据的离散分布，提高内存利用率。它的分区大小是固定的，页分配相较于块有着更小的分配粒度，可能会导致内部内存碎片，不会导致外部内存碎片。通过页表实现物理地址于逻辑地址的对应。
* 段式存储管理：段是数据分配的逻辑单位，段式分配目的是为了更好的反映程序的逻辑结构以更好满足用户需求。它的分区大小是不固定的，会导致外部内存碎片，段相比页拥有实际意义，可以将其分为主程序段，子程序段，数据段和栈段。段是一个二维结构，定位段需要知道它的段名和段内具体物理地址。使用段表来对应物理地址和逻辑地址。
* 段页式存储分配：结合段式分配和页式分配，将主内存区域先分为多个段，在将每个页划分多若干页。结合多段式管理和页式管理的各种优点。

Linux 操作系统是采用**段页式**内存管理方式：页式存储管理能有效地提高内存利用率（解决内存碎片）,而分段存储管理能反映程序的逻辑结构并有利于段的共享。将这两种存储管理方法结合起来,就形成了段页式存储管理方式。 

段页式存储管理方式即先将用户程序分成若干个段,再把每个段分成若干个页,并为每一个段赋予一个段名。

在段页式系统中,为了实现从逻辑地址到物理地址的转换,系统中需要同时配置段表和页表,利用段表和页表进行从用户地址空间到物理内存空间的映射。 

系统为每一个进程建立一张段表,每个分段有一张页表。段表表项中至少包括段号、页表长度和页表始址,页表表项中至少包括页号和块号。在进行地址转换时,首先通过段表查到页表始址,然后通过页表找到页帧号,最终形成物理地址。

