## 操作系统中的内存管理
操作系统内存管理：物理内存管理和虚拟内存管理。

物理内存管理：程序装入等概念、交换技术、连续分配管理方式和非连续分配管理方式（分页、分段、段页式）。

虚拟内存管理：虚拟内存管理包括虚虚拟内存概念、请求分页管理方式、页面置换算法、页面分配策略、工作集和抖动。

## Linux中fork函数的作用
fork函数用来创建一个子进程。
fork()函数，其原型如下：
```C++
#include <unistd.h>  
pid_t fork(void);  
```
fork()函数不需要参数，返回值是一个进程标识符PID。返回值有以下三种情况：
（1） 对于父进程，fork()函数返回新创建的子进程的PID。
（2） 对于子进程，fork()函数调用成功会返回0。
（3） 如果创建出错，fork()函数返回-1。

fork()函数创建一个新进程后，会为这个新进程分配进程空间，将父进程的进程空间中的内容复制到子进程的进程空间中，包括父进程的数据段和堆栈段，并且和父进程共享代码段。这时候，子进程和父进程一模一样，都接受系统的调度。因为两个进程都停留在fork()函数中，最后fork()函数会返回两次，一次在父进程中返回，一次在子进程中返回，两次返回的值不一样，如上面的三种情况。

## 伙伴系统


## 进程和线程相比，为什么慢？
1. 进程系统开销显著大于线程开销；线程需要的系统资源更少。
2. 进程切换开销比线程大。多进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈；多线程切换时只需要切换硬件上下文和内核栈。
3. 进程通信比线程通信开销大。进程通信需要借助管道、队列、共享内存，需要额外申请空间，通信繁琐；而线程共享进程的内存，如代码段、数据段、扩展段，通信快捷简单，同步开销更小。

## 简述Linux零拷贝的原理？
所谓「零拷贝」描述的是计算机操作系统当中，CPU不执行将数据从一个内存区域，拷贝到另外一个内存区域的任务。通过网络传输文件时，这样通常可以节省 CPU 周期和内存带宽。
### 零拷贝的好处
1. 节省了 CPU 周期，空出的 CPU 可以完成更多其他的任务
2. 减少了内存区域之间数据拷贝，节省内存带宽
3. 减少用户态和内核态之间数据拷贝，提升数据传输效率
4. 应用零拷贝技术，减少用户态和内核态之间的上下文切换
### 零拷贝原理

## 简述epoll和select的区别，epoll为什么高效？
### 区别
1. 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；而epoll保证了每个fd在整个过程中只会拷贝一次。
2. 每次调用select都需要在内核遍历传递进来的所有fd；而epoll只需要轮询一次fd集合，同时查看就绪链表中有没有就绪的fd就可以了。
3. select支持的文件描述符数量太小了，默认是1024；而epoll没有这个限制，它所支持的fd上限是最大可以打开文件的数目，这个数字一般远大于2048。
### epoll为什么高效
1. select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。
2. select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而epoll只要一次拷贝，而且把当前进程往等待队列上挂也只挂一次，这也能节省不少的开销。

## 说说多路IO复用技术有哪些，区别是什么？
select，poll，epoll都是IO多路复用的机制，I/O多路复用就是通过一种机制，可以**监视多个文件描述符**，一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。
### 区别
1. poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。
2. select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。
3. select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而epoll只要一次拷贝，而且把当前进程往等待队列上挂也只挂一次，这也能节省不少的开销。

## 死锁定义及发生的条件
### 死锁的定义:
两个或两个以上的进程在执行过程中,因争夺共享资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。 
### 产生死锁的必要条件:
1. 互斥条件：指进程对所分配到的资源进行排它性使用,即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源,则请求者只能等待,直至占有资源的进程用毕释放； 
2. 请求和保持条件：指进程已经保持至少一个资源,但又提出了新的资源请求,而该资源已被其它进程占有,此时请求进程阻塞,但又对自己已获得的其它资源保持不放； 
3. 不剥夺条件：指进程已获得的资源,在未使用完之前,不能被剥夺,只能在使用完时由自己释放；
4. 环路等待条件：指在发生死锁时,必然存在一个进程——资源的环形链,即进程集合 {P0,P1,P2,···,Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源,……,Pn 正在等待已被 P0 占用的资源。

## 内存管理
内存管理主要包括内存的**分配（malloc）**和**释放（free）**，内存的分配可以分为**连续内存分配**和**非连续内存分配**。

**连续分配**：为用户分配一个连续的内存空间，常见的连续分配如块式管理。

**非连续分配**又分为页式存储管理，段式存储管理和段页数存储管理。

* 页式存储管理：页是数据分配的物理单位，页分配是为了实现数据的离散分布，提高内存利用率。它的分区大小是固定的，页分配相较于块有着更小的分配粒度，可能会导致内部内存碎片，不会导致外部内存碎片。通过页表实现物理地址于逻辑地址的对应。
* 段式存储管理：段是数据分配的逻辑单位，段式分配目的是为了更好的反映程序的逻辑结构以更好满足用户需求。它的分区大小是不固定的，会导致外部内存碎片，段相比页拥有实际意义，可以将其分为主程序段，子程序段，数据段和栈段。段是一个二维结构，定位段需要知道它的段名和段内具体物理地址。使用段表来对应物理地址和逻辑地址。
* 段页式存储分配：结合段式分配和页式分配，将主内存区域先分为多个段，在将每个页划分多若干页。结合多段式管理和页式管理的各种优点。

Linux 操作系统是采用**段页式**内存管理方式：页式存储管理能有效地提高内存利用率（解决内存碎片）,而分段存储管理能反映程序的逻辑结构并有利于段的共享。将这两种存储管理方法结合起来,就形成了段页式存储管理方式。 

段页式存储管理方式即先将用户程序分成若干个段,再把每个段分成若干个页,并为每一个段赋予一个段名。

在段页式系统中,为了实现从逻辑地址到物理地址的转换,系统中需要同时配置段表和页表,利用段表和页表进行从用户地址空间到物理内存空间的映射。 

系统为每一个进程建立一张段表,每个分段有一张页表。段表表项中至少包括段号、页表长度和页表始址,页表表项中至少包括页号和块号。在进行地址转换时,首先通过段表查到页表始址,然后通过页表找到页帧号,最终形成物理地址。

## 互斥锁和自旋锁
### 互斥锁 
互斥锁也称为互斥量（Mutex），是一种用来保护临界区的特殊变量， 它可以处于锁定（locked） 状态， 也可以处于解锁（unlocked） 状态： 
- 如果互斥锁是锁定的， 就是某个特定的线程正持有这个互斥锁 
- 如果没有线程持有这个互斥锁，那么这个互斥锁就处于解锁状态 
每个互斥锁内部有一个线程等待队列，用来保存等待该互斥锁的线程。当互斥锁处于解锁状态时， 如果某个线程试图获取这个互斥锁，那么这个线程就可以得到这个互斥锁而不会阻塞；当互斥锁处于锁定状态时， 如果某个线程试图获取这个互斥锁，那么这个线程将阻塞在互斥锁的等待队列内。 
### 自旋锁 
自旋锁与互斥锁类似，但它**不是通过休眠使进程阻塞**，而是在获取锁之前一直**处于忙等（自旋）阻塞状态**。自旋锁可以用于以下情况：**锁被持有的时间短**，而且线程并不希望在重新调度上花费太多的成本。 自旋锁**最多只能被一个可执行线程持有**，如果一个执行线程试图获得一个已经被持有的自旋锁，那么该线程就会一直进行忙循环 - 旋转 - 等待锁重新可用。

## 共享内存
1. 共享内存是**进程间通信**的一种方式。不同进程之间共享的内存通常为**同一段物理内存**，进程可以将同一段物理内存连接到他们自己的地址空间中，**所有的进程都可以访问共享内存中的地址**。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。
 2. 共享内存的**优点**：因为所有进程共享同一块内存，共享内存在各种进程间通信方式中具有最高的效率。访问共享内存区域和访问进程独有的内存区域一样快，并**不需要通过系统调用或者其它需要切入内核的过程**来完成。同时它也避免了对数据的各种不必要的复制。
 3. 共享内存的**缺点**:共享内存**没有提供同步机制**，这使得我们在使用共享内存进行进程之间的通信时，往往需要借助其他手段来保证进程之间的同步工作。

## 进程调度算法有哪些
调度算法是指根据系统的资源分配策略所规定的资源分配算法。常见的进程调度算法有：
1. **先来先服务（FCFS）调度算法** 
先来先去服务调度算法是一种最简单的调度算法，也称为先进先出或严格排队方案。每次调度都是从后备作业（进程）队列中选择一个或多个最先进入该队列的作业（进程），将它们调入内存，为它们分配资源、创建进程，当每个进程就绪后，它加入就绪队列。当前正运行的进程停止执行，选择在就绪队列中存在时间最长的进程运行。
2. **短作业优先（SJF）调度算法** 短作业优先（SJF）的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业（进程），将它们调入内存运行，短进程优先（SPF）调度算法从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或者发生某件事而阻塞时，才释放处理机。
3. **优先级调度算法** 优先级调度算法又称优先权调度算法，该算法既可以用于作业调度，也可以用于进程调度，该算法中的优先级用于描述作业运行的紧迫程度。在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列；在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。 
4. **高响应比优先调度算法** 高响应比优先调度算法主要用于作业调度，该算法是对 FCFS 调度算法和 SJF 调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。 
5. **时间片轮转调度算法** 时间片轮转调度算法主要适用于分时系统。每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。
6. **多级反馈队列调度算法** 多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展，通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。

## 孤儿进程，僵尸进程，如何解决僵尸进程
1. **孤儿进程** 孤儿进程是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 init 进程（进程号为1）所收养，并且由 init 进程对它们完整状态收集工作，孤儿进程一般不会产生任何危害。 
2. **僵尸进程** 僵尸进程是指一个进程使用 fork() 函数创建子进程，如果子进程退出，而父进程并没有调用 wait() 或者waitpid() 系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，**占用系统资源**，这种进程称为僵尸进程。 
3. **解决僵尸进程** 一般，为了防止产生僵尸进程，在 fork() 子进程之后我们都要及时在父进程中使用 wait() 或者 waitpid() 系统调用，等子进程结束后，父进程回收子进程 PCB 的资源。 同时，当子进程退出的时候，内核都会给父进程一个 SIGCHLD 信号，所以可以**建立一个捕获 SIGCHLD 信号的信号处理函数，在函数体中调用 wait() 或 waitpid()**，就可以清理退出的子进程以达到防止僵尸进程的目的。

## 写时拷贝
写时拷贝顾名思义就是“写的时候才分配内存空间”，这实际上是一种拖延战术。传统的 fork() 系统调用直接把所有的资源复制给新创建的进程，这种实现过于简单并且效率低下，因为它拷贝的数据或许可以共享，或者有时候 fork() 创建新的子进程后，子进程往往要调用一种 exec 函数以执行另一个程序。而 exec 函数会用磁盘上的一个新程序替换当前子进程的正文段、数据段、堆段和栈段，如果之前 fork() 时拷贝了内存，则这时被替换了，这是没有意义的。 Linux 的 fork() 使用写时拷贝（Copy-on-write）页实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候，大大提高了效率。

## 动态库静态库的区别和优缺点
### 静态库和动态库的区别： 
1. 命令方式不同 
- 静态库命名 Linux : libxxx.a lib : 前缀（固定） xxx : 库的名字，自己起 .a : 后缀（固定） Windows : libxxx.lib 
- 动态库命名 Linux : libxxx.so lib : 前缀（固定） xxx : 库的名字，自己起 .so : 后缀（固定） Windows : libxxx.dll 
2. 链接时间和方式不同 
- 静态库的链接是将整个函数库的所有数据在**编译**时都整合进了目标代码 
- 动态库的链接是程序**执行**到哪个函数链接哪个函数的库 
### 静态库和动态库的优缺点： 
1. 静态库优缺点 
- 优点：发布程序时无需提供静态库，移植方便，**运行速度相对快**些 
- 缺点：静态链接生成的可执行文件体积较大，**消耗内存**，如果所使用的静态库发生更新改变，程序必须重新编译，更新麻烦。 
2. 动态库优缺点 
- 优点：更加**节省内存并减少页面交换**，动态库改变并不影响使用的程序，动态函数库升级比较方便 
- 缺点：**发布程序时需要提供动态库**

## 条件变量？？
条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待"条件变量的条件成立"而挂起；另一个线程使"条件成立"（给出条件成立信号）。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。 使用条件变量可以以原子方式阻塞线程，直到某个特定条件为真为止。条件变量始终与互斥锁一起使用，对条件的测试是在互斥锁（互斥）的保护下进行的。如果条件为假，线程通常会基于条件变量阻塞，并以原子方式释放等待条件变化的互斥锁。如果另一个线程更改了条件，该线程可能会向相关的条件变量发出信号，从而使一个或多个等待的线程执行以下操作： 唤醒 再次获取互斥锁 重新评估条件。


