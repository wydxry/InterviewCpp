## 红黑树
### 有了二叉搜索树，为什么还需要平衡二叉树？
在学习二叉搜索树、平衡二叉树时，我们不止一次提到，二叉搜索树容易退化成一条链
这时，查找的时间复杂度从O(log2N)也将退化成O(N)
引入对左右子树高度差有限制的平衡二叉树，保证查找操作的最坏时间复杂度也为O(log2N)
### 有了平衡二叉树，为什么还需要红黑树？
AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡
在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣
红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，整体性能优于AVL
红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决
红黑树的红黑规则，保证最坏的情况下，也能在O(log2N)时间内完成查找操作。
### 红黑规则
* 节点不是黑色，就是红色（非黑即红）
* 根节点为黑色
* 叶节点为黑色（叶节点是指末梢的空节点 Nil或Null）
* 一个节点为红色，则其两个子节点必须是黑色的（根到叶子的所有路径，不可能存在两个连续的红色节点）
* 每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同的黑色高度）
### 红黑树的应用
1. Java中，TreeMap、TreeSet都使用红黑树作为底层数据结构
2. JDK 1.8开始，HashMap也引入了红黑树：当冲突的链表长度超过8时，自动转为红黑树
3. Linux底层的CFS进程调度算法中，vruntime使用红黑树进行存储
4. 多路复用技术的Epoll，其核心结构是红黑树 + 双向链表
5. C++中，set和map都使用了红黑树作为底层数据结构

### 红黑树的重要知识点

从二叉搜索树 → AVL，严格控制左右子树高度差，避免二叉搜索树退化成链表（时间复杂度从O(log 2N) 退化成O(N)
从AVL → 红黑树，牺牲严格的平衡要求，以换取新增/删除节点时少量的旋转操作，平均性能优于AVL；通过红黑规则，保证在最坏的情况下，也能拥有O(log 2N)的时间复杂度

红黑规则
红黑树节点的定义、红黑树的定义、红黑树的左旋、右旋操作
红黑树新增节点后的调整，记住左儿子的情况，举一反三右儿子的情况
红黑树删除节点后的调整，记住左儿子的情况，举一反三右儿子的情况

## 各类查找算法
查找算法分为静态查找和动态查找。
**静态查找**包括：顺序查找、折半查找、分块查找；
**动态查找**包括：二叉排序树和平衡二叉树。
### 分块查找（索引顺序查找）
先将查找表分成若干个子表，要求第一个块的最大关键字小于第二个块的所有关键字，以此类推，这样保证块间是有序的，把各个子表中的最大关键字组成一个索引表，表中还包含各子表的起始地址。表的特点就是块间有序，块内无序。因此，查找时块间进行顺序查找或折半查找，块内进行顺序查找。
### 哈希表查找（散列表）
根据关键字码的值直接访问的数据结构，即通过关键字的值映射到表中的一个位置以加快查找速度，其中映射函数叫做散列函数，存放记录的数组叫做散列表。
#### 散列函数的构造方法
1. 直接定址法
2. 除留余数法
3. 平方取中法
4. 数字分析法
5. 折叠法
6. 随机数法
#### 哈希冲突的解决方法
1. 线性探测法
2. 平方探测法
3. 再散列法
4. 伪随机序列法
5. 拉链法

### B树和B+树
#### B树（多路平衡查找树）
B树，又称多路平衡查找树，B树中所有节点的孩子个数的最大值称为B树的阶，通常用m表示。
一颗m阶B树或为空树，或为满足如下特性的m叉树：
1. 树中的每个节点至多有m颗子树，至少还有m-1个关键字
2. 若根节点不是终端节点，则至少有两颗子树
3. 除根节点外的所有非叶节点至少还有【m/2】颗子树，即至少含有【m/2】-1个关键字
4. 所有的叶节点都出现在同一层次上，并且不带信息。

#### B+树
B+树是应数据库所需而出现的一种B树的变形树。
一颗m阶B+树需满足下列条件：
1. 每个分支节点最多有m颗子树
2. 非叶根节点至少有两颗子树，其他每个分支节点至少【m/2】颗子树
3. 节点的子树个数与关键字个数相等
4. 所有叶节点包含全部关键字及指向相应记录的指针


